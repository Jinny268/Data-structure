<해싱>

1. 해싱에 대해서..
 - [핵심] 해싱은 O(log n) 시간보다 빠른 연산을 위해, 키와 1차원 리스트의 인덱스의 관계를 이용하여 키(원소)를 저장한다.
 - 키를 배열의 인덱스로 그대로 사용하면 메모리 낭비가 심해질 수 있다.
 - [문제 해결 방안] 키를 변환하여 배열의 인덱스로 사용한다.
 - 키를 간단한 함수를 사용해 변환한 값을 배열의 인덱스로 이용하여 원소를 저장하는 것을 해싱이라고 한다.
 - 해싱에 사용되는 함수를 해시함수라고 한다.
 - 해시함수가 계산한 값을 해시값 또는 해시주소라고 한다.
 - 항목이 해시값에 따라 저장되는 배열을 해시테이블이라고 한다.

2. 해싱의 문제점
 - 아무리 우수한 해시함수를 사용하더라도, 2개 이상의 원소를 해시테이블의 동일한 곳에 저장하는 경우가 발생한다.
 - 서로 다른 키들이 동일한 해시값을 가질 때 충돌이 발생한다.

3. 해시함수
 - 가장 이상적인 해시함수는 키들을 균등하게 해시테이블의 인덱스로 변환하는 함수이다.
 - 일반적으로 키들은 부여된 의미나 특성을 가지므로 키의 가장 앞 부분 또는 뒤의 몇 자리 등을 취하여 해시값으로 사용하는 방식의 해시함수는 많은 충돌을 야기한다.
 - 균등하게 변환한다는 것은 키들을 해시테이블에 랜덤하게 흩어지도록 저장하는 것을 뜻한다.
 - 해시함수는 키들을 균등하게 해시테이블의 인덱스로 변환하기 위해 의미가 부여되어 있는 키를 간단한 계산을 통해 뒤죽박죽으로 만든 후 해시테이블의 크기에 맞도록 해시값을 계산한다.
 - 아무리 균등한 결과를 보장하는 해시함수라도 함수 계산 자체에 긴 시간이 소요된다면 해싱의 장점인 연산의 신속성을 상실하므로 그 가치를 잃는다.
 - 해쉬 함수는 주소 계산이 빨라야하며, 가급적 서로 다른 키의 함수 값이 중복되어서는 안된다.
 - 균일 해쉬 함수는 M개의 slot 각각에 임의의 k가 대응될 확률은 모두 같다.
 
 4. 대표적인 해시함수
 - 중간제곱 함수: 키를 제곱한 후, 적절한 크기의 중간부분을 해시값으로 사용한다.
 - 접기 함수: 큰 자리수를 갖는 십진수를 키로 사용하는 경우, 몇 자리씩 일정하게 끊어서 만든 숫자들의 합을 이용해 해시값을 만든다.
 - 나눗셈 함수: 키를 소수 M(나눗셈 연산을 했을 때, 소수가 키들을 균등하게 인덱스로 변환시키는 성질을 갖기 때문에 이용)으로 나눈 뒤, 그 나머지를 해시값으로 사용한다. h(key) = key % M이고, 따라서 해시테이블의 인덱스는 0에서 M-1이 된다.
 - 곱셈 함수: 1보다 작은 실수 적재율을 키에 곱하여 얻은 숫자의 소수 부분을 테이블 크기 M과 곱한다. 이렇게 나온 값의 정수 부분을 해시값으로 사용한다.
 - 위 해시 함수들의 공통점: 키의 모든 자리의 숫자들이 함수 계산에 참여함으로써 계산 결과에서는 원래의 키에 부여된 의미나 특성을 찾아볼 수 없게 된다.
 - 가장 널리 사용되는 해시함수: 나눗셈 함수
 
5. 개방주소방식
(1) 개방주소방식(Open Addressing)은 해시테이블 전체를 열린 공간으로 가정하고 충돌된 키를 일정한 방식에 따라서 찾아낸 empty 원소에 저장한다.
(2) Collision 해결 방법: 선형조사, 제곱조사, 이중해싱
(3) 선형조사:
   - 충돌이 일어난 원소에서부터 순차적으로 검색하여 처음 발견한 empty 원소에 충돌이 일어난 키를 저장한다.
   - h(key) = i라면, 해시테이블 a[i], a[i+1], a[i+2], …, a[i+j] 를 차례로 검색하여 처음으로 찾아낸 empty 원소에 key를 저장한다.
   - 해시테이블은 1차원 리스트이므로, i + j가 M이 되면 a[0]을 검색한다.
   -순차탐색으로 empty 원소를 찾아 충돌된 키를 저장하므로 해시테이블의 키들이 빈틈없이 뭉쳐지는 현상이 발생한다. [1차 군집화(Primary Clustering)]
   - 이러한 군집화는 탐색, 삽입, 삭제 연산 시 군집된 키들을 순차적으로 방문해야 하는 문제점을 야기한다.
   - 군집화는 해시테이블에 empty 원소 수가 적을수록 더 심화되며 해시성능을 극단적으로 저하시킨다.
(4) 제곱조사
   - 이차조사(Quadratic Probing)는 선형조사와 근본적으로 동일한 충돌해결 방법이다.
   - 이차(제곱)조사는 이웃하는 빈 곳이 채워져 만들어지는 1차 군집화 문제를 해결한다.
   - 같은 해시값을 갖는 서로 다른 키들인 동의어(Synonym)들이 똑같은 점프 시퀀스(Jump Sequence)를 따라 empty 원소를 찾아 저장하므로 결국 또 다른 형태의 군집화인 2차 군집화(Secondary Clustering)를 야기한다.
   - 점프 크기가 제곱 만큼씩 커지므로 배열에 empty 원소가 있는데도 empty 원소를 건너뛰어 탐색에 실패하는 경우도 피할 수 없다.
(5) 이중해싱
   - 이중해싱(Double Hashing)은 2 개의 해시함수를 사용한다.
   - 하나는 기본적인 해시함수h1(key)로 키를 해시테이블의 인덱스로 변환하고, 제2의 함수 h2(key)는 충돌 발생 시 다음 위치를 위한 점프 크기를 다음의 규칙에 따라 정한다.
   - 이중해싱은 동의어들이 저마다 제2 해시함수를 갖기 때문에 점프 시퀀스가 일정하지 않는다.
   - 이중해싱은 모든 군집화 문제를 해결한다.
   - 제 2의 함수 h2(key)는 점프 크기를 정하는 함수이므로 0을 리턴해선 안된다.
   - 그 외의 조건으로 h2(key)의 값과 해시테이블의 크기 M과 서로 소(Relatively Prime) 관계일 때 좋은 성능을 보인다.
   - 해시테이블 크기 M을 소수로 선택하면, 이 제약 조건을 만족한다.
   - 전형적인 2차 해시함수 h2, h2(key)=R − ( key % R ), 여기서 R은 M보다 작은 소수이다.
   - 이중해싱은 빈 곳을 찾기 위한 점프 시퀀스가 일정하지 않으며, 모든 군집화 현상을 발생시키지 않는다. 
   - 또한 해시 성능을 저하시키지 않는 동시에 해시테이블에 많은 키들을 저장할 수 있다는 장점을 가지고 있다.

6. 폐쇄주소방식
(1) 폐쇄주소방식(Closed Addressing)의 충돌해결 방법은 키에 대한 해시값에 대응되는 곳에만 키를 저장한다.
(2) 충돌이 발생한 키들은 한 위치에 모아 저장한다.
(3) 이를 구현하는 가장 대표적인 방법: 체이닝(Chaining)

7. 재해시
 - 어떤 해싱방법도 해시테이블에 비어있는 장소가 적으면, 삽입에 실패하거나 해시성능이 급격히 저하되는 현상을 피할 수 없다. 이러한 경우, 해시테이블을 확장시키고 새로운 해시함수를 사용하여 모든 키들을 새로운 해시테이블에 다시 저장하는 재해시가 필요하다.
 - 재해시는 오프라인(Off-line)에서 이루어지고 모든 키들을 다시 저장해야 하므로 O(N) 시간이 소요된다.
 - 재해시 수행 여부는 적재율(Load Factor)에 따라 결정한다.
 - 적재율 = (테이블에 저장된 키의 수 N)/ (테이블 크기 M)
 - 일반적으로 적재율 > 0.75가 되면 해시 테이블 크기를 2 배로 늘리고, 적재율 < 0.25가 되면 해시테이블을 1/2로 줄인다.
 
8. 해시방법의 성능 비교 및 응용
 - 해시방법의 성능은 탐색이나 삽입 연산을 수행할 때 성공과 실패한 경우를 각각 분석하여 측정한다.
 - 선형조사는 적재율이 너무 작으면 해시테이블에 empty 원소가 너무 많고, 적재율 값이 1.0에 근접할수록 군집화가 심화된다.
 - 개방주소방식의 해싱은 적재율이 0.5, 즉, M =2N일 때 상수시간 성능 보인다.
 - 일반적으로 M이 소수이고, 적율이 10 정도이면 O(1) 시간 성능을 보인다.
