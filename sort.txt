<정렬>

1. 정렬이란?
(1) 데이터를 순서대로 재배열하는 것이다.
   - 가장 기본적이고 중요한 알고리즘이다.
   - 비교할 수 있는 모든 속성들은 정렬의 기준이 될 수 있다.
   - ex) 오름차순과 내림차순
   - 정렬이란 레코드들을 키의 순서대로 재배열하는 것이다.
(2) 용어 정리
   - 레코드: 정렬시켜야 될 대상
   - 정렬 키: 정렬의 기준이 되는 필드

2. 정렬 알고리즘의 종류
(1) 정렬 장소에 따른 분류
   - 내부 정렬: 모든 데이터가 메인 메모리
   - 외부 정렬: 외부 기억 장치에 대부분의 레코드가 존재
(2) 단순하지만 비효율적인 방법
   - 삽입, 선택, 버블정렬 등
(3) 복잡하지만 효율적인 방법
   - 퀵, 힙, 병합, 기수정렬, 팀 등
(4) 정렬 알고리즘의 안정성

3. 간단한 정렬 알고리즘
(1) 선택 정렬: 오른쪽 리스트에 서 가장 작은 숫자를 선택하여 왼쪽 리스트의 맨 뒤로 이동하는 작업을 반복
   - 시간 복잡도: O(n^2)
   - 알고리즘이 간단, 자료 이동 횟수가 미리 결정된다.
(2) 삽입 정렬: 정렬되어 있는 부분에 새로운 레코드를 올바른 위치에 삽입하는 과정 반복
   - 최선의 경우 시간 복잡도는 O(n), 최악의 경우 시간 복잡도는 O(n^2), 평균의 경우 시간 복잡도는 O(n^2)이다.
   - 많은 이동이 필요해 레코드가 큰 경우 불리하고, 안정된 정렬 방법이며 대부분 정렬되어 있으면 매우 효율적이라는 특징이 있다.
   - 이미 정렬된 파일의 뒷부분에 소량의 신규 데이터를 추가하여 정렬하는 경우(입력이 거의 정렬된 경우)  우수한 성능을 보인다.
   - 입력 크기가 작은 경우에도 매우 좋은 성능을 보인다. 삽입 정렬은 재귀 호출을 하지 않으며, 프로그램도 매우 간단하기 때문이다.
   - 삽입 정렬은 합병정렬이나 퀵정렬과 함께 사용되어 실질적으로 보다 빠른 성능에 도움을 준다. (단, 이론적인 수행 시간은 향상되지 않음.)
(3) 버블 정렬: 인접한 2개의 레코드를 비교하여 순서대로 서로 교환 하는 것을 리스트 전체에 수행한다. 끝으로 이동한 레코드를 제외하고 다시 이 과정을 반복한다.
   - 비교 횟수(최상, 평균, 최악의 경우 모두 일정)하므로 시간복잡도도 O(n^2)으로 일정하다.
   - 이동 횟수: 평균의 경우 O(n^2)이다. 역순으로 정렬된 경우가 최악인데 이때의 이동횟수는 3*비교횟수이다. 또한 이미 정렬된 경우가 최선인데 이때에는 이동 횟수는 0이다. 
   - 레코드의 이동 과다: 이동연산은 비교연산보다 더 많은 시간이 소요된다.

4. 힙 정렬 (최대힙을 이용)
(1) 1단계: 리스트를 최대힙으로 만든다.
   - heapify 을 이용
   - n = len(A)
     for i in range(n//2-1, -1, -1):   // step 1
         heapify(A,  i,  n);
(2) 2단계: 최대힙을 정렬된 리스트로 만든다.
   - 먼저 힙의 루트에 있는 원소 A[0] (즉, 최대 원소)와 마지막 원소 A[last]를 교환한다.
   - 힙의 크기를 1 줄인다. 루트가 0인 semiheap에 대하여 heapify를 호출하여 힙으로 만든다.
   - last(힙의 마지막 노드의 위치) = 0이 될 때까지 위의 단계 1-2를 반복한다. 
   - heap_size = n
     for last in range(n-1, 0, -1)
         heap_size -= 1;
         heapify(A,  0,  heap_size )
(3) 힙정렬 수행시간 분석
   - 1단계: O(nlogn)
   - 2단계: O(nlogn)
   - 1단계+2단계: O(nlogn)
